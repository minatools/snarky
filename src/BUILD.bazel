load(
    "@obazl_rules_ocaml//ocaml:rules.bzl",
    "ocaml_archive",
    "ocaml_interface",
    "ocaml_module",
    "ocaml_ns_module",
)

COMMON_OPTS = select({
    "//bzl/config:enable_verbose": ["-verbose"],
    "//conditions:default": [],
}) + ["-thread"]

LINK_OPTS = select({
    "//bzl/config:enable_always_link": ["-linkall"],
    "//conditions:default": [],
}) + []

EXEC_OPTS = COMMON_OPTS + LINK_OPTS + []
IMPL_OPTS = COMMON_OPTS + LINK_OPTS + []
INTF_OPTS = COMMON_OPTS + LINK_OPTS + []
ARCHIVE_OPTS = COMMON_OPTS + LINK_OPTS + []
COMMON_DEPS = []

SNARKY_NS = "Snarky"

PPX = "@//bzl/ppx:ppx[ppx_snarky][ppx_jane][ppx_deriving.enum][ppx_deriving.eq][bisect_ppx]"
PPX_ARGS = [
    # do not sort (buildifier)
    "-conditional",
    "-cookie",
    "library-name=\"snarky\"",
    "-corrected-suffix",
    ".ppx-corrected",
]

ocaml_archive(
    name = "snarky",
    opts = ARCHIVE_OPTS,
    visibility = ["//visibility:public"],
    deps = [
        # do not sort (buildifier)
        "@opam//pkg:base64",
        "@opam//pkg:bignum",
        "@opam//pkg:core_kernel",
        "@opam//pkg:ctypes",

        "//src/camlsnark_c",
        "//ctypes_foreign:ctypes_foreign_libffi",
        "//bitstring_lib",
        "//fold_lib",
        "//h_list",
        "//interval_union",

        "//src/base:snarky_backendless",
        "//src/camlsnark_c/cpp_string:snarky_cpp_string",
        "//src/camlsnark_c/cpp_vector:snarky_cpp_vector",
        "//src/camlsnark_c/libsnark_bindings:snarky_libsnark_bindings",
        "//src/intf:snarky_intf",
        "//tuple_lib",
        "@opam//pkg:yojson",

        ":snarky_ns_module",
        ":gpu_prover.cm_",
        ":backend_types.cm_",
        ":backends.cm_",
        ":snark.cm_",
        ":snarky.cm_",
        ":toplevel.cm_",
        ## end ns_module
    ],

    cc_linkstatic = select({
        "//bzl/host:linux": True,
        "//bzl/host:macos": False
    }, no_match_error = "camlsnark_c snark_ffi_bindings.cm_: unsupported platform.  Linux or MacOS only."),

    ## For now, because link ordering is critical for statically
    ## linking, we attach all cc libs here.  A future version of OBazl
    ## will support attaching them to the modules that directly use
    ## them.
    cc_deps = {
        ## ORDER MATTERS for static linking.
        # do not sort (buildifier)

        ## libsnark_ffi_bindings depends on both libvector_ffi_bindings and libsnark_caml
        "//src/camlsnark_c:snark_ffi_bindings": "default",
        ## libsnark_caml depends on libvector_ffi_bindings
        "@libsnark//caml:snark_caml": "default",
        "//src/camlsnark_c/cpp_vector/gen:vector_ffi_bindings": "default",


        ## snark_caml depends on various parts of @libff.
        ## bazel does not produce libff.a, we have to list each dep.

        ## bn128 depends on ate_pairing
        "@libff//libff/algebra/curves/bn128": "default",
        "@ate_pairing//libzm": "default",

        "@libff//libff/common:common": "default",

        "@libff//libff/algebra/curves/alt_bn128": "default",
        "@libff//libff/algebra/curves/alt_bn128:public_params": "default",
        "@libff//libff/algebra/curves/edwards": "default",
        "@libff//libff/algebra/curves/mnt": "default",
        "@libff//libff/algebra/curves/mnt/mnt4": "default",
        # "@libff//libff/algebra/curves/mnt/mnt4:public_params": "default",
        "@libff//libff/algebra/curves/mnt/mnt6": "default",
        # "@libff//libff/algebra/curves/mnt/mnt6:public_params": "default",
        "@libff//libff/algebra/curves/mnt753": "default",
        "@libff//libff/algebra/curves/mnt753/mnt4753": "default",
        # "@libff//libff/algebra/curves/mnt753/mnt4753:public_params": "default",
        "@libff//libff/algebra/curves/mnt753/mnt6753": "default",
        # "@libff//libff/algebra/curves/mnt753/mnt6753:public_params": "default",

        "@libff//libff/algebra/fields": "default",
        "@libff//libff/algebra/fields:bigint": "default",

        "@libff//libff/common/default_types": "default",
        "@libff//libff/common:logging": "default",
        "@libff//libff/common:profiling": "default",
        "@libff//libff/common:utils": "default",

        "@libsnark//caml:common": "default",


        "//bzl/external/openssl": "default",
        "//bzl/external/libgmp": "default",
        "//bzl/external/libsodium": "default",
        "//bzl/external/openmp": "default",
    }
)

ocaml_ns_module(
    name = "snarky_ns_module",
    ns = SNARKY_NS,
    submodules = [
        ## These are all included as submodules in snarky.ml,
        ## but we're building a namespace archive named "snarky",
        ## so they must be included as submodules of this ns module;
        ## otherwise we get e.g.:
        ## File "src/snarky.ml", line 47, characters 18-26:
        ## Error: Unbound module Toplevel
        "backend_types.ml",
        "backends.ml",
        "gpu_prover.ml",
        "snark.ml",
        "snarky.ml",
        "toplevel.ml"
    ]
)

ocaml_interface(
    name = "backend_types.cmi",
    src = "backend_types.mli",
    ns_module = ":snarky_ns_module",
    ppx = PPX,
    ppx_args = PPX_ARGS,
    opts = INTF_OPTS,
    deps = [
        "@opam//pkg:ctypes",
        "//src/camlsnark_c",
        "//src/camlsnark_c/bindings:camlsnark_c_bindings"
    ],
)

ocaml_module(
    name = "backend_types.cm_",
    intf = ":backend_types.cmi",
    src  = "backend_types.ml",
    ns_module = ":snarky_ns_module",
    opts = IMPL_OPTS,
    ppx = PPX,
    ppx_args = PPX_ARGS,
    deps = [
        "@opam//pkg:ctypes",
        "//src/camlsnark_c",
        "//src/camlsnark_c/bindings:camlsnark_c_bindings"
    ],
)

ocaml_module(
    name = "backends.cm_",
    src  = "backends.ml",
    ns_module = ":snarky_ns_module",
    opts = IMPL_OPTS,
    ppx = PPX,
    ppx_args = PPX_ARGS,
    deps = ["//src/camlsnark_c/libsnark_bindings:snarky_libsnark_bindings"]
)

ocaml_module(
    name = "snark.cm_",
    src  = "snark.ml",
    ns_module = ":snarky_ns_module",
    opts = IMPL_OPTS,
    ppx = PPX,
    ppx_args = PPX_ARGS,
    deps = [
         "//src/base:snarky_backendless",
        ":backends.cm_",
    ],
)

ocaml_module(
    name = "toplevel.cm_",
    src  = "toplevel.ml",
    ns_module = ":snarky_ns_module",
    opts = IMPL_OPTS,
    ppx = PPX,
    ppx_args = PPX_ARGS,
    deps = [
        "@opam//pkg:core_kernel",
        "@opam//pkg:base64",
        "@opam//pkg:yojson",
        "//h_list",
        "//src/base:snarky_backendless",
        "//src/camlsnark_c/libsnark_bindings:snarky_libsnark_bindings",
        "//src/intf:snarky_intf",
        ":backends.cm_"
    ],
)

ocaml_module(
    name = "snarky.cm_",
    src  = "snarky.ml",
    ns_module = ":snarky_ns_module",
    opts = IMPL_OPTS,
    ppx = PPX,
    ppx_args = PPX_ARGS,
    deps = [
        "//src/base:snarky_backendless",
        "//src/intf:snarky_intf",
        "//src/camlsnark_c/cpp_vector:snarky_cpp_vector",
        "//src/camlsnark_c/libsnark_bindings:snarky_libsnark_bindings",
        "//ctypes_foreign:ctypes_foreign_libffi",
        # ":toplevel.cm_"
    ],
)

ocaml_module(
    name = "gpu_prover.cm_",
    src  = "gpu_prover.ml",
    ns_module = ":snarky_ns_module",
    opts = IMPL_OPTS,
    # ppx = PPX,
    # ppx_args = PPX_ARGS,
    visibility = ["//visibility:public"],
)

genrule(
    name = "gpu_prover",
    srcs = select({
        "//bzl/config:enable_gpu": ["gpu_prover.gpu.ml"],
        "//conditions:default":    ["gpu_prover.no_gpu.ml"],
    }),
    outs = [
        "gpu_prover.ml"
    ],
    cmd = "cp $< $@"
)
